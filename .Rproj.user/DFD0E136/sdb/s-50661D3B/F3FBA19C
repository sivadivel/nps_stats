{
    "collab_server" : "",
    "contents" : "library(MCMCpack)\n\n##### CREDIBLE INTERVALS ON ONE NPS SCORE #################\n\n# Assuming a multinomial distribution for the number of\n# detractors, neutrals and promoters, and a Dirichlet prior for the parameters\n# of the multinomial, the posterior distribution of the counts of people in \n# each category is distributed Dirichlet with parameters =  alpha(i) + x(i)\n\n# Take 100k samples from posterior and convert to NPS score\n# np = # of promoters; nq = # of neutrals; nd = # of detractors\nnps.sim <- function(np,nq,nd){\n  # Parameters of minimally informative Dirichlet prior\n  alpha <- c(0.000001, 0.000001, 0.000001)\n  \n  # Parameters of Dirichlet posteriors \n  theta <- c(np, nq, nd) + alpha\n  \n  ns <- 100000 # Number of simulations \n  \n  # n random draws from Dirichlet(theta)\n  sim <- rdirichlet(ns, theta)\n  \n  # Convert to NPS scores\n  nps <- 100 * (sim[,1] - sim[,3])\n  return(nps)\n}\n\n# Calculate point estimate and credible intervals\nnps.results <- function(sim){\n  # Point estimate and credible intervals\n  point <- mean(sim)\n  lb <- quantile(sim, 0.025)\n  ub <- quantile(sim, 0.975)\n  \n  out <- list(lb, point, ub)\n  names(out) <- c('Lower Bound', 'Point Estimate', 'Upper Bound')\n  return(out)\n}\n\nnps <- nps.sim(9,0,2)\nresults <-nps.results(nps)\nresults\n\n# Plot posterior\nhist(nps, breaks=100)\n{abline(v=results[1], col='red', lwd=3)\nabline(v=mean(nps), col='red', lwd=3)\nabline(v=results[3], col='red', lwd=3)}\n\n\n##### CREDIBLE INTERVALS ON THE DIFFERENCE BETWEEN TWO NPS SCORES #######\n\n# Take 100k samples from posterior and convert to NPS score\n# and convert to difference in NPS scores\nnps.sim.2test <- function(np1,nq1,nd1,np2,nq2,nd2){\n  # Parameters of minimally informative Dirichlet prior\n  alpha1 <- c(0.00001, 0.00001, 0.00001)\n  alpha2 <- c(0.00001, 0.00001, 0.00001)\n  \n  # Parameters of Dirichlet posteriors \n  theta1 <- c(np1, nq1, nd1) + alpha1\n  theta2 <- c(np2, nq2, nd2) + alpha2\n  \n  ns <- 100000 # Number of simulations \n  \n  # n random draws from Dirichlet(theta)\n  sim1 <- rdirichlet(ns, theta1)\n  sim2 <- rdirichlet(ns, theta2)\n  \n  # Convert to NPS scores\n  nps1 <- 100 * (sim1[,1] - sim1[,3])\n  nps2 <- 100 * (sim2[,1] - sim2[,3])\n  \n  # Compute difference between nps scores\n  diff.nps <- nps1 - nps2\n  \n  return(diff.nps)\n}\n\n# Calculate point estimate and credible intervals\nnps.results.diff <- function(sim){\n  # Point estimate and credible intervals\n  point <- mean(sim)\n  lb <- quantile(sim, 0.025)\n  ub <- quantile(sim, 0.975)\n  \n  out <- c(lb, point, ub)\n  return(out)\n}\n\nnps <- nps.sim.2test(9,0,2,2,0,9)\nresults <- nps.results(nps)\nresults\n\n# Plot posterior\n{hist(nps, breaks=100)\nabline(v=results[[1]], col='red', lwd=3)\nabline(v=mean(nps), col='red', lwd=3)\nabline(v=results[[3]], col='red', lwd=3)}\n\n################## POWER ANALYSIS #########################\n\n# Length of one side of the credible intervals\n# at a sample size of n\n{\n  ss <- c(20,30,50,75,100,150,200,300,500) # Sample sizes\n  ci <- NULL # Credible intervals\n  sim <- NULL # Results of simulation\n  for(i in 1:length(ss)){\n    sim <- nps.sim(ss[i]/2,ss[i]/2,ss[i])\n    ci[i] <- (nps.results(sim)[[3]] - nps.results(sim)[[1]])/2\n    print(ss[i])\n  }\n  pow <- data.frame(ss, ci)\n  pow\n}\n\n# Plot of size of CIs at various sample sizes\n{\nplot(ss, ci, type='l', ylim=c(-25,25), ylab='Width of Confidence Interval of NPS',\n     xlab='Sample Size', main='Power Analysis on NPS Confidence Interval')\nlines(ss, -ci)\npolygon(c(ss, rev(ss)), c(ci, rev(-ci)), col=\"skyblue\", border = \"red\")\ngrid()\nlines(c(ss[1],ss[length(ss)]), c(0,0) ,col='red')\nfor(i in 1:length(ss)) lines(c(ss[i],ss[i]),c(ci[i],-ci[i])) \n}\n\n# Minimum difference needed to be detected \n# at a sample size of n (total sample size 2*n)\n{\nss <- c(10,20,30,50,75,100,150,200,300,500) # Sample sizes\nci <- NULL\nsim <- NULL\nfor(i in 1:length(ss)){\n  sim <- nps.sim.2test(ss[i]/2,ss[i]/2,ss[i],ss[i]/2,ss[i]/2,ss[i])\n  ci[i] <- (nps.results.diff(sim)[[3]] - nps.results.diff(sim)[[1]])/2\n  print(i)\n}\npow <- data.frame(ss, ci)\npow\n}\n\n# Plot of size of CIs of difference between two\n# scores at various sample sizes\n{\n  plot(ss, ci, type='l', ylim=c(-51,51), ylab='Width of CI of Difference between Two NPS Scores',\n       xlab='Sample Size', main='Power Analysis on Difference between Two NPS Scores')\n  lines(ss, -ci)\n  polygon(c(ss, rev(ss)), c(ci, rev(-ci)), col=\"lightgreen\", border = \"red\")\n  grid()\n  lines(c(ss[1],ss[length(ss)]), c(0,0) ,col='red')\n  for(i in 1:length(ss)) lines(c(ss[i],ss[i]),c(ci[i],-ci[i])) \n}\n\n# Minimum difference needed to be detected \n# at a sample size of n (total sample size 2*n)\n{\n  ss1 <- c(10,20,30,50,75,100,150,200,300,500) # Sample size 1\n  ss2 <- c(10,20,30,50,75,100,150,200,300,500) # Sample size 1\n  ci <- data.frame()\n  sim <- NULL\n  for(i in 1:length(ss1)){\n    for(j in 1:length(ss2)){\n      sim <- nps.sim.2test(ss1[i]/2,ss1[i]/2,ss1[i],ss2[j]/2,ss2[j]/2,ss2[j])\n      ci[i,j] <- (nps.results.diff(sim)[[3]] - nps.results.diff(sim)[[1]])/2\n      print(c(i,j))\n    }\n  }\n  row.names(ci) <- ss1\n  names(ci) <- ss1\n  ci\n}\n\n# Plot of size of CIs of difference between two\n# scores at various sample sizes\n{\n  plot(ss, ci, type='l', ylim=c(-51,51), ylab='Width of CI of Difference between Two NPS Scores',\n       xlab='Sample Size', main='Power Analysis on Difference between Two NPS Scores')\n  lines(ss, -ci)\n  polygon(c(ss, rev(ss)), c(ci, rev(-ci)), col=\"lightgreen\", border = \"red\")\n  grid()\n  lines(c(ss[1],ss[length(ss)]), c(0,0) ,col='red')\n  for(i in 1:length(ss)) lines(c(ss[i],ss[i]),c(ci[i],-ci[i])) \n}\n",
    "created" : 1499038858414.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "55|51|78|0|\n",
    "hash" : "4238807443",
    "id" : "F3FBA19C",
    "lastKnownWriteTime" : 1498695255,
    "last_content_update" : 1499038900590,
    "path" : "~/Desktop/nps_stats/nps_bayesian.R",
    "project_path" : "nps_bayesian.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}